%!TEX root = ../thesis.tex

\chapter{Eigener Ansatz: Social Online Community Connectors (SOCC)} % (fold)
\label{cha:eigener_ansatz_social_online_community_connectors_socc_}

Aufbauend auf den in Kapitel \ref{cha:analyse} identifizierten Komponenten und Wahl der für ein System zur Synchronisation von Beiträgen passenden Techniken, soll nun der als \emph{Social Online Community Connectors} (SOCC) benannte Ansatz vorgestellt werden. Der Aufbau von SOCC ist in Abbildung \ref{fig:uebersicht_socc} zu sehen. Ein \emph{Connector} von SOCC dient dabei als Schnittstelle zwischen den Datenformat der Plattform für die er implementiert wurde und dem SIOC-Format. SOCC stützt sich dabei auf die Prinzipien für die Verbindung von Daten im Web von Tim Berners-Lee \cite{Berners-Lee2009}:

\begin{description}
    \item[\enquote{Use URIs as names for things}:] Ressourcen wie Seiten, Foren, Threads und Beiträge sollten immer durch eine URI benannt werden.

    \item[\enquote{Use HTTP URIs so that people can look up those names}:] Die verwendeten URIs sollten einer Adresse im Web entsprechen, um auf die dahinter liegenden Daten zugreifen zu können.

    \item[\enquote{When someone looks up a URI, provide useful information, using the standards (RDF*, SPARQL)}:] Die Daten sollten in einen Standard für das Semantic Web formatiert werden. Wie schon erwähnt, setzt SOCC dazu auf RDF und darauf aufbauenden Ontologien FOAF und SIOC. Dadurch können zum Beispiel andere Anwendungen mit Abfragen in SPARQL\footnote{\url{http://www.w3.org/TR/sparql11-overview}} nach Beiträgen in den Daten suchen.

    \item[\enquote{Include links to other URIs. so that they can discover more things.}:] Nicht nur die Struktur eine Diskussion kann über Links rekonstruiert werden, auch der Gewinnen zusätzlicher Informationen ist so möglich. Beiträge können auf Lernmaterialien wie Folien oder Videos verweisen oder über das FOAF-Profil eines Autor können weitere Beiträge von ihm gefunden werden. 
\end{description}

URIs sind also das wichtigste Element mit denen SOCC arbeitet. Soll zum Beispiel eine Diskussion synchronisiert werden, muss einem Connector die URI übergeben werden, hinter der sich die Daten befinden. Ein Connector ist nur für eine einzige Plattform zuständig. Aber eine Plattform kann über mehrere Connectoren angesprochen werden.

\begin{figure}[ht]
    \centering
    \includegraphics[
        width=0.5\textwidth,
        keepaspectratio=true]
    {assets/images/socc_connector_overview}
    \caption{Übersicht der Komponenten der SOCC}
    \label{fig:uebersicht_socc}
\end{figure}

Intern besteht ein Connector aus drei Komponenten die zum einen für das Lesen (\emph{PostReader}) und Schreiben (\emph{PostWriter}) von Beiträgen verwendet werden und zum andren aus einen \emph{StructureReader} der für das Auslesen der Struktur der Plattform verantwortlich ist. Eine genaue Beschreibung dieser Komponenten folgt in Abschnitt \ref{sec:design_eines_connectors}.

Jeder Connector hat Zugriff auf eine als \emph{Triplestore} bezeichnete Datenbank in der RDF-Triple gespeichert und mit SPARQL abgefragt werden können. Der Connector benutzt diesen Triplesore als Speicher in dem seine Konfigurationsdaten lagern, aber auch für zusätzliche Daten die er von Außerhalb benötigt. Er wird aber auch benutzt, um Daten zu speichern, die während des Betriebes anfallen, da sie so irgendwann wieder verwendet werden können ohne sie erneut von der Plattform laden zu müssen. Zum Beispiel die Daten über die Struktur der verwendeten Plattform, die sich selten ändert.

Die Beiträge werden dann zwischen den einzelnen Connectoren über ein Nachrichtennetzwerk auf der Basis von Camel ausgetauscht. Die Beschreibung dieser als \emph{SOCC-Camel} bezeichneten Komponnente erfolgt in Abschnitt \ref{sec:socc_camel}.

% section datenformat (end)

\section{Konfiguration} % (fold)
\label{sec:konfiguration}

Damit ein Connector funktionieren kann, muss er von Außen Informationen bekommen, welche er zum Betrieb braucht. Dies sind zum Beispiel Informationen zu Benutzerkonten oder Parameter für die verwendete API. Die wichtigsten Informationen für die Konfiguration der Connectoren stellen die Benutzerkonten dar. Sie enthalten unter anderem die Informationen, um Zugriff auf die Operationen der einzelnen APIs zu erhalten. Da die Benutzerkonten, wie später im Abschnitt \ref{sub:benutzerdaten} beschrieben, im FOAF-Format gespeichert werden, stellt es sich als Vorteil heraus die übrigen Informationen ebenfalls im Triplestore zu speichern und mit den schon vorhandenen zu verbinden. 

Aus diesem Grund wurde für die Konfiguration eines Connectors die \emph{SOCC Connector Config Ontology} entwickelt. Diese Ontologie ist sehr einfach gehalten und baut auf schon vorhandenen Ontologien auf. Zusätzlich musste die SIOC-Ontologie so erweitert werden, dass die Integration von Authentifizierungs- und Autorisierungsinformationen möglich war. 

\subsection{SOCC Connector Config Ontologie} % (fold)
\label{sub:connector_config_ontologie}

Der Aufbau der SOCC Connector Config Ontologie (RDF-Präfix \texttt{ccfg:}) ist in der Abbildung \ref{fig:uebersicht_conector_cfg} zu sehen. Die Konfigurationsdaten für einen Connector werden dabei durch die Klasse \texttt{ccfg:ConnectorConfig} modelliert. Diese Klasse enthält dann die folgenden Eigenschaften für den Connector.

\begin{figure}[ht]
    \centering
    \includegraphics[
        width=\textwidth,
        keepaspectratio=true
    ]{assets/images/connector_config_ontology}
    \caption{Schema der SOCC Connector Config Ontology}
    \label{fig:uebersicht_conector_cfg}
\end{figure}

Jeder Connector erhält einen eindeutigen \texttt{ccfg:id}, um jeden Connector später eindeutig identifizieren zu können. Die Eigenschaft \texttt{ccfg:connectorClassName} beschreibt den vollständigen Java-Klassennamen des beschriebenen Connectors. Diese wird für das Laden der richtigen Implementierung benötigt. Manchmal kann es passieren, dass keine passendes Benutzerkonto zum Schreiben eins Beitrags gefunden werden kann. Dadurch es es wünschenswert solche Beiträte dahingegen zu verändern, dass eine Verweis auf den original Autor und vielleicht wo der Beitrag gemacht wurde vorhanden ist. Durch die Eigenschaft \texttt{ccfg:unknownMessageTemplate} kann eine Vorlage für das Aussehen des Verweises definiert werden. Innerhalb dieser Vorlage stehen einige Variablen in der Form \enquote{\texttt{\{varName\}}} zur Verfügung, wobei \enquote{varName} durch den Namen der entsprechenden Variable zu ersetzen ist. Welche Variablen alle vorhanden sind und mit welchen Werten diese ersetzt werden ist in Tabelle \ref{tbl:unknown_message_template_vars} zu sehen. 

\begin{table}[ht]
    \caption{Variablennamen und Ersetzung innerhalb von \texttt{ccfg:unknownMessageTemplate} }
    \centering
    \begin{tabular}{l|l}
        \textbf{varName} & \textbf{Ersetzt durch} \\
        \hline
        \texttt{message} & Original Beitrag \\
        \texttt{sourceUri} & URI des original Beitrags \\
        \texttt{connectorId}  & ID des aktuellen Connectors \\
        \texttt{serviceName}  & Name des vom Connector verwendeten Service \\
        \texttt{creationDate} & Erstelldatum des Beitrags (falls bekannt) \\
        \texttt{authorName}   & Name des Autors (falls bekannt)          
    \end{tabular}
    \label{tbl:unknown_message_template_vars}
\end{table}

Für die Nutzung einiger APIs müssen zusätzlich bestimmte Parameter angegeben werden. Dies könnte zum Beispiel die genau Adresse des Dienstes sein. Hierzu wird auf das \emph{SIOC Services Modul}\footnote{\url{http://rdfs.org/sioc/services\#}} zurückgegriffen. Diese stellt eine Klasse \texttt{siocs:Service} zur Verfügung und über die Eigenschaft \texttt{ccfg:service} kann eine solche Servicebeschreibung einen Connector zugewiesen werden. Der genaue Aufbau eines solchen Services wird im Abschnitt \ref{sub:services} beschrieben. Die letzte Information für die Konfiguration eins Connectors ist eine Standardbenutzer (Im Folgenden Defaultuser genannt) und wird mit der Eigenschaft \texttt{ccfg:defaultUserAccount} festgelegt. Dieser Defaultuser erfüllt im Großen und Ganzen zwei Aufgaben. Als Erstes wird er für lesende Zugriffe der API auf die verwendete Plattform genutzt. Hierzu ist ein einzelnes Benutzerkonto vollkommen ausreichend, da nur die gelesenen Daten wichtig sind und nicht von welchen Konto sie kommen. Es sollte aber ein Konto mit weitreichenden Befugnissen sein, um möglichst viel Daten lesen zu können. Die zweite Aufgabe bezieht sich auf das stellvertretende Schreiben einzelner Benutzer. Nicht immer werden die dazu notwendigen Daten von den Benutzer zur Verfügung gestellt oder sind unbekannt. In diesem Fall wird der Defaultuser genutzt und der Inhalt des Beitrags in die Form der mit der Eigenschaft \texttt{\texttt{ccfg:unknownMessageTemplate}} festgelegten Vorlage konvertiert. 

% subsubsection connector_config_ontology (end)

\subsection{Services} % (fold)
\label{sub:services}

Wie eben schon beschrieben, existiert für SIOC ein Modul zur einfachen Modellierung von Diensten auf semantischer Ebene: Das SIOC Services Module (RDF-Präfix \texttt{siocs:}). Kernstück dieses Moduls ist die Klasse \texttt{siocs:Service}. Wie auf Abbildung \ref{fig:uebersicht_sioc_services} zu sehen ist. Mit dieser Klasse kann durch eine Hand voll Eigenschaften ein Service beschrieben werden. Für diese Arbeit ist davon die wichtigste Eigenschaft \texttt{siocs:service\_endpoint}. Durch diese kann die Adresse festgelegt werden, unter dem ein Service erreichbar ist. Gerade bei Plattformen die nicht an eine feste Adresse (Foren, Blogs, $\dots$) gebunden sind, ist diese Angabe unerlässlich. Die Eigenschaften \texttt{siocs:has\_service} und \texttt{siocs:service\_of} sind ideal zur Verbindung von einzelnen \texttt{sioc:UserAccount}s mit einem Service. Diese Verbindung hilft dabei für das stellvertretende Schreiben von Beiträgen schnell die passenden Benutzerdaten zu finden. Ebenfalls nützlich ist \texttt{siocs:max\_results}. Manche Dienste erlauben es nur eine maximale Anzahl an Ergebnissen pro Aufruf zurückgeben zu lassen. Da sich diese Anzahl über die Zeit ändern kann ist es nicht sinnvoll diese fest im Programm festzulegen. Für SOCC weniger interessant aber der Vollständigkeit halber seien noch \texttt{siocs:service\_protocol} zum Angeben des verwendeten Übertragungsprotokolls REST, SOAP, $\dots$) und \texttt{siocs:service\_definition} mit dem auf eine weiterführende Definition verwiesen werden kann erwähnt. 

\begin{figure}[ht]
    \centering
    \includegraphics[
        width=0.8\textwidth,
        keepaspectratio=true
    ]{assets/images/sioc_services_ontology}
    \caption{SIOC Services Module}
    \label{fig:uebersicht_sioc_services}
\end{figure}

% subsection services (end)

\subsection{Benutzerdaten} % (fold)
\label{sub:benutzerdaten}

Soll ein Beitrag eines Benutzers von Google+ nach Facebook synchronisiert werden und es so aussehen, als hat er diesen Beitrag selbst auf Facebook geschrieben, sind gute Kenntnisse über alle Benutzerkonten dieser einen Person notwendig. Als erstes muss die Existenz dieser Person dem System bekannt sein. Hierzu kann diese durch die Klasse \texttt{foaf:Person} aus der FOAF Ontologie dargestellt werden. Für ein einzelnes Benutzerkonto wurde in SIOC die Klasse \texttt{sioc:UserAccount} definiert. Da \texttt{sioc:UserAccount} eine Unterklasse von \texttt{OnlineAccount} aus FOAF ist, kann diese über die Eigenschaft \texttt{foaf:account} beziehungsweise \texttt{sioc:account\_of} mit einer Person verbunden werden. Ebenso ist es wichtig zu wissen, zu welchen Plattform ein Benutzerkonto gehört. Deshalb wird der \texttt{sioc:UserAccount} mit einem Objekt der Klasse \texttt{siocs:Service} über die Eigenschaft \texttt{siocs:has\_service}/\texttt{siocs:service\_of} zusammengebracht. Diese Verbindung ist für manche APIs besonders bedeutend, da in dem Serviceobjekt relevante Daten für den Zugriff darauf enthalten sind. Nun kann es vorkommen, dass eine Person mehrere Benutzerkonten für private und geschäftliche Dinge besitzt. Um nicht private Beiträge auf Webseite A mit dem geschäftlichen Benutzerkonto auf Webseite B zu schreiben, muss ein Mapping zwischen den verschiedenen Benutzerkonten festgelegt werden. Dieses Mapping kann über ein in der SOCC Connector Config Ontologie definierte Eigenschaft \texttt{ccfg:mapped\_to} für die Klasse \texttt{sioc:UserAccount} realisiert werden. Diese Eigenschaft ist als symmetrisch definiert. Also falls Benutzerkonto A mit Benutzerkonto B über \texttt{ccfg:mapped\_to} verbunden ist, dann gilt dies ebenfalls für B mit A. Abbildung \ref{fig:usermanagement} zeigt den Zusammenhang zwischen der Klasse \texttt{foaf:Person}, \texttt{sioc:UserAccount} und \texttt{siocs:Service} sowie der Eigenschaft \texttt{ccfg:mapped\_to} noch einmal graphisch an einem Beispiel.

\begin{figure}[ht]
    \centering
    \includegraphics[
        width=0.8\textwidth,
        keepaspectratio=true,]
    {assets/images/usermanagement}
    \caption{Zusammenhang von Person, UserAccount und Service. Die inversen Eigenschaften \texttt{sioc:account\_of} und \texttt{siocs:service\_of} wurden zu einer besseren Übersicht weggelassen}
    \label{fig:usermanagement}
\end{figure}

% subsubsection benutzerdaten (end)

\subsection{Authentifizierung} % (fold)
\label{sub:authentifizierung}

Die Ontologien FOAF und SIOC sind hervorragend für die Abbildung von sozialen Netzwerken und Diskussionen geeignet, jedoch ist es mit ihnen nicht möglich Daten zur Authentifizierung (Feststellen ob jemand der ist, den er vorgibt zu sein) zu speichern. Wegen dem Schutz der Privatsphäre ist dies verständlich, jedoch um stellvertretend für einen Benutzer Beiträge zu schreiben, ist es wichtig Zugriff auf diese Daten zuhaben und sie einem Benutzerkonto zuordnen zu können. Zuerst muss dazu aber festgestellt werden, welche verschiedenen Mechanismen es zum Anmelden an ein solches Konto existieren.

\begin{description}
    \item[Benutzername/Passwort] ist wohl eine der ersten und häufigsten Mechanismen, um den Zugriff sensibler Daten vor Dritten zu schützen. Moodle und Youtube setzen zum Beispiel den Benutzername und Passwort eines angemeldeten Benutzers zu Authentifizierung ein.
    
    \item[OAuth] ist technisch gesehen eher ein Mechanismus zur Autorisierung als zu Authentifizierung. Da es aber auch Informationen enthält die ein Programm zur Authentifizierung von sich gegenüber einer API enthält, wird es in diesen Abschnitt behandelt. OAuth\footnote{\url{http://oauth.net/}} wird heutzutage hauptsächlich für den Zugriff auf webbasierte APIs verwendet. Benutzer können so temporär Programmen den Zugriff auf ihre Daten erlauben und später wieder verbieten. Die aktuelle Version stellt OAuth 2.0 dar und wird in dieser Version von den größten Seitenbetreibern wie Google, Facebook oder Microsoft eingesetzt\footnote{\url{http://en.wikipedia.org/wiki/OAuth\#List\_of\_OAuth\_service\_providers}}. Insgesamt sind für die Nutzung von OAuth vier Parameter wichtig. Für das Programm, dass Zugriff erhalten möchte, sind es die Parameter \emph{client\_id} und \emph{client\_secret} (Siehe \cite{rfc6749}[S.\,8]). Sie authentifizieren das Programm gegenüber der API. Will man nun eine von OAuth geschützte Funktion nutzen, ist ein sogenannter Accesstoken nötig (Siehe \cite{rfc6749}[S.\,9]). Da dieser Accesstoken in der Regel nur eine bestimmte Zeit gültig ist, wird je nach Implementierung des Standards noch ein Refreshtoken mitgeliefert. Mit diesem Refreshtoken ist das Programm in der Lage ohne Zutun des Benutzers einen abgelaufen Accesstoken wieder zu aktivieren. Dies kann beliebig oft wiederholt werden, bis der Benutzer beide Token für ungültig erklärt. 
    %\todo[inline]{vll. noch OAuth 1.0(a) einbauen}
    
    \item[API Schlüssel] sind eine dritte Möglichkeit Programmen Zugriff auf eine API zu gewähren. Der API Schlüssel entspricht ungefähr einer Kombination von client\_id und client\_secret von OAuth. Dieser Schlüssel schaltet in der Regel nicht den Zugriff auf persönliche Daten von Benutzer frei. Dafür ist noch ein weiterer Mechanismus, wie die Verwendung von einem Benutzername und Passwort nötig. Die in Abschnitt \ref{sub:youtube_connector}  beschriebene Google Youtube API ist hierzu ein gutes Beispiel.
\end{description}

Neben diesen drei Mechanismen wäre noch der Vollständigkeit halber die HTTP-Authentifizierung zu nennen. Hierbei handelt es ich um eine Form des Benutzername-Passwort-Verfahrens, welches auf dem HTTP Protokoll aufsetzt. Für einfachen Webseiten ist dies eine unkomplizierte Art Dateien vor fremden Zugriffen zu schützten. Für aktuelle APIs von Webanwendungen ist diese Form der Authentifizierung nicht mehr Stand der Technik.

Die Suche nach einer bestehen Ontologie, welche zusammen mit SIOC verwendet werden könnte, gestaltete sich als sehr schwierig. Letztendlich wurde dann doch die \emph{Authentication Ontology}\footnote{\url{http://omnivoke.kmi.open.ac.uk/authentication/}} (RDF-Prefix \texttt{waa:}) des \emph{OmniVoke}\footnote{\url{http://omnivoke.kmi.open.ac.uk/framework/}} Frameworks gefunden. Die Art der Authentifizierung wird darin durch die Klasse \texttt{waa:AuthenticationMechanism} modelliert. Unterklassen davon für die wichtigsten Mechanismen wie \texttt{waa:OAuth}, \texttt{waa:WebAPI} und Benutzername/Passwort (dort \texttt{waa:Direct} genannt) sind vorhanden. Jedem AuthenticationMechanism Objekt können dann \texttt{waa:Credentials} (engl. für Anmeldedaten) hinzugefügt werden.

\begin{figure}[ht]
    \centering
    \includegraphics[
        width=\textwidth,
        keepaspectratio=true]
    {assets/images/sioc_services_authentication}
    \caption{SIOC Services Authentication Ontology}
    \label{fig:uebersicht_sioc_services_authentication}
\end{figure}

Das einzige Manko an dieser Ontologie war das Fehlen von Credentials für OAuth in der Version 2.0. Im einzelnen waren dies Klassen für Client-ID, Client-Secret, sowie für Access- und Refreshtoken. Um auch diese OAuth Version unterstützen zu können, wurden hierfür die Klassen \texttt{siocsa:ClientId}, \texttt{siocsa:ClientSecret}, \texttt{siocsa:AccessToken} und \texttt{siocsa:RefreshToken} als Unterklassen von \texttt{waa:Credentials} abgeleitet. Als Letztes musste noch eine Verbindung zwischen Authentication Ontology und SIOC hergestellt werden. Zum einen war eine Erweiterung der Klasse \texttt{sioc:UserAccount} notwendig, so dass die Anmeldedaten der Benutzer zur Verfügung standen, zum anderen werden Daten wie ein API-Schlüssel von einem Service benötigt, die von denen der Benutzer unabhängig sind. Für die Klasse \texttt{sioc:UserAccount} wurde die Eigenschaft \texttt{siocsa:accountAuthentication} geschaffen. Diese erwartet als Subjekt einen \texttt{sioc:UserAccount} und als Objekt ein \texttt{waa:AuthenticationMechanism}, welcher dann die Credentials enthält. Für die Klasse \texttt{sioc:Service} existiert das Äquivalent \texttt{siocsa:serviceAuthentication}. 

Diese Erweiterungen und die übernommenen Teile der Authentication Ontology wurden danach im \emph{SIOC Services Authentication Module} (RDF-Präfix \emph{siocsa:}) zusammengefasst. Graphisch ist sie in Abbildung \ref{fig:uebersicht_sioc_services_authentication} und im Anhang \ref{sec:anhang_sioc_services_authentication_module} als OWL Schema zu sehen. 

% subsection authorization (end)

\subsection{Autorisierung} % (fold)
\label{sub:autorisierung}

Da für viele Menschen im Web ihre Privatsphäre wichtig ist, sollte von den Benutzern für das Lesen und Schreiben ihrer Beiträge erst ihre Erlaubnis dazu eingeholt werden. Ein verbreitetes Mittel für eine solche Zugriffssteuerung sind Access Control Lists (ACL) (engl. für Zugriffsteuerungsliste). Mit ihnen wird geregelt, wer bestimmte Operationen auf eine Ressource durchführen darf. Für den Einsatz in dieser Arbeit wurde die \emph{Basic Access Control Ontologie} (siehe \cite{Hollenbach2009,wiki:wacl})(RDF-Präfix \texttt{acl:}) ausgewählt (Im Folgenden nur als ACL bezeichnet). Da sie Teilweise auf FOAF aufbaut, ließ sie sich sehr einfach in das bestehende System integrieren.

\begin{figure}[ht]
    \centering
    \includegraphics[
        width=\textwidth,
        keepaspectratio=true]
        {assets/images/w3c_web_acl}
    \caption{Basic Access Control Ontologie}
    \label{fig:w3c_web_acl}
\end{figure}

Zugriffsrechte für Ressourcen werden in dieser ACL mit der Klasse \texttt{acl:Access} modelliert. Von dieser Klasse werden einzelne Rechte wie \texttt{acl:Read} für das Lesen und \texttt{acl:Write} für das Schreiben abgeleitet. Nebenbei existieren noch die Ableitungen \texttt{acl:Control} für die Kontrolle über die ACL und \texttt{acl:Append} zum Anfügen von Daten an die Ressource. Die letzten beiden Rechte sind aber für SOCC unbedeutend.

Die Verbindung von einen Zugriffsrecht mit eine Ressource wird über die Klasse \texttt{acl:Authorization} erreicht. Der Besitzer dieser Autorisierung wird durch die Eigenschaft \texttt{alc:owner} festgelegt und gehört zur Klasse \texttt{foaf:Agent} beziehungsweise der davon abgeleiteten Klasse \texttt{foaf:Person}. Mittels der Eigenschaft \texttt{acl:agent} wird festgelegt für welche Person/Agent diese Autorisierung gilt. Das selbe wird auch über die Eigenschaft \texttt{acl:agentClass} bestimmt, wobei hier eine abstrakte Klasse statt ein Objekt davon gemeint ist. Soll zum Beispiel der öffentlicher Zugriff für eine Ressource definiert werden, wird bei \texttt{acl:agentClass} die Klasse \texttt{foaf:Agent} eingesetzt (vgl. \cite[\enquote{Public Access}]{wiki:wacl}). Dies besagt, dass alle Agenten auf diese Ressource zugreifen können. Innerhalb von SOCC werden nur Ressourcen verarbeiten, die so öffentlich zugänglich gemacht wurden. Welche Rechte für eine Ressource eingeräumt werden, kann über die Eigenschaft \texttt{acl:mode} festgelegt werden. SOCC testet aber nur ob das Recht \texttt{acl:Read} zum Lesen oder \texttt{acl:Write} zum Schreiben von Beiträgen eingeräumt wurde. Auf welche Ressource  sich letztendlich eine Autorisierung bezieht, wird über die Eigenschaft \texttt{acl:accessTo} geregelt. Die Angabe von \enquote{http://www.facebook.com} würde sich für SOCC zum Beispiel auf alle Beiträge des Besitzers auf Facebook beziehen, \enquote{https://canvas.instructure.com/courses/798152} dahingegen nur auf alle Beiträge innerhalb eines Canvas Kurses mit der ID \enquote{798152}. Für einen Zugriff auf alle Beiträge prüft SOCC, ob die Eigenschaft \texttt{acl:accessToClass} auf die Klasse \texttt{sioc:Post} verweist. So müsste nicht jede einzelne Webseite angegeben werden, wenn man ein generelles Zugriffsrecht auf seine Beiträge einräumen will.

Das Listing \ref{lst:acl_beispiel} zeigt ein Beispiel, wie eine Autorisierung mit der ACL in Turtle aussehen könnte. Der Besitzer dieser Autorisierung mit der URI \texttt{http:/example.org\#john} wird in Zeile 2 festgelegt. Er erlaubt damit SOCC einen öffentlichen (Zeile 3), lesenden (Zeile 4) Zugriff auf all seine geschrieben Beiträge (Zeile 5).

\begin{lstlisting}[
    caption={Basic Access Control Beispiel in Turtle }\label{lst:acl_beispiel},
    captionpos=t]
[] a acl:Authorization ;
    acl:owner <http:/example.org#john> ;
    acl:agentClass foaf:Agent ;
    acl:mode acl:Read ;
    acl:accessToClass sioc:Post .
\end{lstlisting}

% subsection autorisierung (end)

% section konfiguration (end)

\section{Design eines Connectors} % (fold)
\label{sec:design_eines_connectors}

\begin{wrapfigure}{r}{8cm}
    \centering
    \includegraphics[
        width=8cm,
        keepaspectratio=true,
        clip=true,
        trim= 246 258 259 8]
    {assets/images/socc_uml_classdiagram}
    \caption{PostReader}
    \label{fig:uml_connector_interface}
\end{wrapfigure}

Die rechte Abbildung \ref{fig:uml_connector_interface} zeigt die Schnittstelle \texttt{IConnector} gegen die ein Connector implementiert werden muss. Sie bietet Zugriff auf die Eigenschaften die mit der Klasse \texttt{ccfg:ConnectorConfig} für die Konfiguration eines Connectors im Triplestore bereitgestellt werden. Diese Schnittstelle definiert Methoden über welche die Komponenten zum Lesen der Seitenstruktur mit dem StructureReader, sowie zum Lesen und Schreiben von Beiträgen mit PostReader und PostWriter zugänglich sind. Zuzüglich werden noch Methoden für den Zugriff auf Hilfskomponenten wie den \emph{SOCC Context}, \emph{AccessControl} und \emph{ClientManger} bereitgestellt. Das UML-Klassendiagramm in Abbildung \ref{fig:connector_uml_classdiagram} zeigt die Beziehung zwischen den Connector und den anderen Komponenten aus dem er besteht, welche in den folgenden Unterabschnitten noch weiter erklärt werden.

Für den Lebenszyklus eines Connectors sind noch die Methoden \texttt{initialize()} und \texttt{shutdown()} wichtig. Nach dem Erzeugen eines Connectors muss die Methode \texttt{initialize()} aufgerufen, um noch mögliche Vorarbeiten durchzuführen bevor der Connector genutzt werden kann. Ob ein Connector schon initialisiert wurde, kann mit der Methode \texttt{isInitialized()} überprüft werden. Bevor eine Connector gelöscht werden kann, sollte noch die Methode \texttt{shutdown()} aufgerufen werden. Sie dient dazu verwendete Ressourcen wieder freizugeben.

\begin{figure}[p]
    \centering
    \includegraphics[
        scale=0.95,
        keepaspectratio=true,
        angle=90]
    {assets/images/socc_uml_classdiagram}
    \caption{UML-Klassendiagramm der Connectoren}
    \label{fig:connector_uml_classdiagram}
\end{figure}

% subsection design_eines_connectors (end)

\subsection{SOCC Context} % (fold)
\label{sub:socc_context}

\begin{wrapfigure}{r}{6cm}
    \centering
    \includegraphics[
        width=6cm,
        keepaspectratio=true,
        clip=true,
        trim= 35 340 520 9]
    {assets/images/socc_uml_classdiagram}
    \caption{SOCC Context}
    \label{fig:uml_socc_context}
\end{wrapfigure}

Der SOCCContext eines Connectors, beschreibt die Umgebung die er zum Arbeiten braucht. Über ihn bekommt der Connector Zugriff auf den Triplestore, der durch die Klasse \texttt{Model} der RDF2Go Bibliothek abstrahiert wird (Siehe Abschnitt \ref{sec:verwendete_bibliotheken_und_programme}). In ihm befinden sich alle Daten die der Connector für seinen Betrieb benötigt und benutzt ihn gleichzeitig als Lagerplatz für Daten die während des Betriebs gespeichert werden müssen. Eine Referenz auf dieses Triplestore erhält der Connector über den Aufruf der Funktion \texttt{getModel()}. Durch die Methode \texttt{getAccessControl()} kann der Connector über die im folgenden Abschnitt beschriebene AccessControl-Schnittstelle auf die Information für die Autorisierung zugreifen. 

% subsubsection socc_context (end)

\subsection{ClientManager} % (fold)
\label{sub:clientmanager}

\begin{wrapfigure}{r}{7cm}
    \centering
    \includegraphics[
        width=7cm,
        keepaspectratio=true,
        clip=true,
        trim= 497 257 9 9]
    {assets/images/socc_uml_classdiagram}
    \caption{ClientManager}
    \label{fig:uml_clientmanager}
\end{wrapfigure}

Der Zugriff innerhalb des Programms auf eine API erfolgt in der Regel über einen Client. Dieser Client erlaubt es mit den Anmeldedaten für ein Benutzerkonto auf die Funktionen der API über verschiedene Methoden zu zugreifen. Da ein Client immer nur mit einem Benutzerkonto verknüpft ist und von diesen eine große Anzahl verwaltet werden müssen, enthält jeder Connector einen eigen ClientManager für diese Aufgaben. Für alle vom Benutzer unabhängigen Daten erhält der ClientManager ein wie Abschnitt \ref{sub:services} beschriebenes Objekt der Klasse \texttt{sioc:Service}, das oftmals wichtige Daten wie Client-ID und Client-Secret enthält. Das Erzeugen eines neuen Clients erfolgt dann durch den Aufruf der Methode \texttt{createClient(\dots)}. Als Parameter wird er ein Benutzerkonto (\texttt{sioc:UserAccount}) übergeben. Sind alle erforderlichen Authentifizierungsinformation aus Abschnitt \ref{sub:authentifizierung} vorhanden, wird ein neuer Client erstellt und zurück an den Aufrufer gegeben. Dieser Client wird aber dadurch nicht automatisch vom ClientManager verwaltet. Hierzu muss der im vorherigen Schritt erzeugte Client durch die Übergabe an \texttt{add(userAccount: UserAccount, client: T )} dauerhaft mit den angegeben Benutzerkonto verknüpft und intern gespeichert werden. In der aktuellen Implementierung ist es wichtig, dass die Eigenschaften \texttt{foaf:accountName} und \texttt{foaf:accountServiceHomepage} des \texttt{sioc:UserAccount}-Objekts gesetzt sind. Aus diesen wird ein eindeutiger Schlüssel generiert, der zur Zuordnung von Benutzerkonto und Client innerhalb des ClientManagers dient. Des weiteren stehen noch Methoden \texttt{remove(userAccount: UserAccount)} zum Entfernen, \texttt{get(userAccount: UserAccount)} zum Suchen von Clients sowie \texttt{contains(userAccount: UserAccount)} zum Testen, ob ein Client zu einem Benutzerkonto existiert zur Verfügung. Sollen zum Beispiel am Ende der Laufzeit des Programms alle erzeugten Clients auf einmal abgemeldet und gelöscht werden, kann dies über die Methode \texttt{clear()} erfolgen. Der ClientManager verwaltet ebenfalls den Client für den in Abschnitt \ref{sub:connector_config_ontologie} angesprochenen Defaultuser. Dieser \emph{Defaultclient} kann über die Methode  \texttt{setDefaultClient(client: T)} gesetzt und durch \texttt{getDefaultClient()} jederzeit wieder abgerufen werden. 

% subsubsection clientmanager (end)

\subsection{AccessControl} % (fold)
\label{sub:accesscontrol}

\begin{wrapfigure}{r}{11cm}
    \centering
    \includegraphics[
        width=11cm,
        keepaspectratio=true,
        clip=true,
        trim= 35 8 350 340]
    {assets/images/socc_uml_classdiagram}
    \caption{AccessControl}
    \label{fig:uml_accesscontrol}
\end{wrapfigure}

Die AccessControl-Schnittstelle ist sehr einfach gehalten und dient für den Zugriff auf die in Abschnitt \ref{sub:autorisierung} beschriebenen ACL-Information. Die Methode \texttt{checkAccessTo(\dots)} prüft, ob der Zugriff auf eine Ressource mit allen übergebenen Rechten erlaubt ist. Die andere Methode \texttt{checkAccessToClass} ist zur Überprüfung, ob die Rechte für den Zugriff auf eine komplette Klasse von Ressourcen vorhanden sind.

\wrapfill 

% subsubsection accesscontrol (end)

\subsection{StructureReader} % (fold)
\label{sub:structurereader}

\begin{wrapfigure}{r}{9cm}
    \centering
    \includegraphics[
        width=9cm,
        keepaspectratio=true,
        clip=true,
        trim= 20 109 456 206]
    {assets/images/socc_uml_classdiagram}
    \caption{StructurReader}
    \label{fig:uml_structure_reader}
\end{wrapfigure}

Um auf Informationen über die Struktur von Foren, sozialen Online-Netzwerken und so weiter im SIOC-Format zugreifen zu können, implementiert jeder Connector dazu einen StructureReader. Die Struktur lässt sich, wie im Abschnitt \ref{ssub:semantically_interlinked_online_communities} vorgestellt, durch die SIOC Klassen \texttt{sioc:Site} und \texttt{sioc:Container} (sowie Unterklassen davon) beschreiben. Für den Zugriff auf diese Struktur, enthält der StructureReader mehrere Methoden die in der UML-Klasse rechts in Abbildung \ref{fig:uml_structure_reader}) zu sehen sind. \wrapfill

\begin{description}
    \item[\textbf{\texttt{getSite()}}] ist eine Methode, welche die Beschreibung einer Seite (Forum, Blog, soziales Online-Netzwerk) als Objekt der SIOC-Klasse \texttt{sioc:Site} zurücklieft. Dieses wird relativ häufig gebraucht, um die Zugehörigkeit anderer Objekte durch einen Verweis auf diese Seite zu verdeutlichen. Dies kann bei einigen APIs nützlich sein, da dort manchmal keine Information zum Ursprungsort eines Beitrags mitgeliefert werden, über den man sonst eine Beziehung zwischen Seite und Beitrag herstellen könnte.

    \item[\textbf{\texttt{isContainer(uri: URI)}}] wird zu Überprüfung verwendet, ob sich hinter einer URI ein potenzieller Container für Beiträge oder andere Container befindet. 

    \item[\textbf{\texttt{getContainer(URI)}}] liefert Informationen zu einen Container im SIOC-Format, der sich hinter der übergeben URI befindet.

    \item[\textbf{\texttt{hasChildContainer(uri: URI)}}] überprüft, ob der Container hinter der übergeben URI weitere Container als Kinder besitzt. Diese Methode wird dazu eingesetzt, um vorab zu testen, ob der Aufruf von \texttt{listContainer(URI)} das gewünschte Ergebnis liefert oder ein Fehler auftreten würde. 

    \item[\textbf{\texttt{listContainer(\dots)}}] sind Methoden, welche für den das Auflisten aller Container einer Seite (aus der Sicht des Defaultusers) zur Verfügung stehen. Die Methode ohne Parameter listet alle Container auf der ersten Ebene der Seitenstruktur auf . Dies könnten zum Beispiel alle Kurse innerhalb von Canvas oder alle beigetretenen Gruppen auf Facebook sein. Die zweite Methode mit einer URI als Parameter gibt eine Liste alle Container, welche den Container hinter der übergeben URI als Elternteil haben zurück. Dies könnten im Falle von Canvas alle Diskussionsthemen innerhalb eines Kurses sein.
\end{description}

% subsubsection structurereader (end)

\subsection{PostReader} % (fold)
\label{sub:postreader}

\begin{wrapfigure}{r}{9cm}
    \centering
    \includegraphics[
        width=9cm,
        keepaspectratio=true,
        clip=true,
        trim= 243 129 255 206]
    {assets/images/socc_uml_classdiagram}
    \caption{PostReader}
    \label{fig:uml_post_reader}
\end{wrapfigure}

Der \texttt{PostReader} dient als Schnittstelle für das Lesen geschriebener Beiträge innerhalb eines Containers oder der Kommentare auf einen anderen Beitrag. Er stellt nach außen hin Funktionen bereit mit denen entweder ein einzelner Beitrag oder alle Beiträge, die bestimmte Kriterien erfüllen, gelesen werden können. Bevor ein Beitrag zurück gegeben wird, müssen die Methoden prüfen, ob der Autor eines Beitrag das Lesen für diesen erlaubt hat. Falls nicht, wird der Beitrag aus der Ergebnisliste gelöscht. Die Funktionsweise der einzelnen Methoden ist wie folgt:

\begin{description}
    \item[\textbf{\texttt{isPost(uri: URI)}}] kann zur Überprüfung eingesetzt werden, ob sich hinter einer URI ein Beitrag befindet.

    \item[\textbf{\texttt{getPost(uri: URI)}}] ist dazu gedacht einen einzelnen Beitrag anhand seiner URI zu lesen. Sie liefert dann den Beitrag als Objekt der SIOC-Klasse \texttt{sioc:Post} zurück.

    \item[\textbf{\texttt{hasPost(uri: URI)}}] funktioniert ähnlich wie \texttt{isPost(\dots)}, überprüft aber ob sich hinter der angegeben URI noch weitere Beiträge befinden können. 

    \item[\textbf{\texttt{pollPosts(uri: URI, since: Date, limit: int)}}] ist eine Methode die alle Beiträge hinter eine URI liest, welche die übergeben Kriterien erfüllen. Insgesamt erhält diese Methode drei Parameter. Der Erste ist eine URI die den Ort angibt, von der die Beiträge gelesen werden sollen. Mit dem zweiten Parameter kann ein Zeitpunkt angegeben werden, ab dem ein zu lesender Beitrag geschrieben sein muss. Zum Beispiel der Zeitpunkt als diese Methode das letzte mal aufgerufen wurde, um alle Beiträge die danach geschrieben wurden zu lesen. Der letzte Parameter gibt eine obere Schranke an, wie viele Beiträge maximal pro Aufruf dieser Methode gelesen werden dürfen. Ist dieses Limit erreicht, werden keine weiteren Beiträge in die Ergebnisliste aufgenommen.
\end{description}

% subsubsection postreader (end)

\subsection{PostWriter} % (fold)
\label{sub:postwriter}

In Abbildung \ref{fig:postwriter_sequenzdiagramm} ist ein UML-Sequenzdiagramm der PostWriter-Komponente zu sehen. Dort ist visualisiert, welche Schritte für das stellvertretende Schreiben von Beiträgen eines Benutzers unternommen werden müssen. Soll nun Beiträge in die Plattform des Connectors geschrieben werden, wird die Methode \texttt{writePosts(URI, String, Syntax)} mit dem Zielort als URI, den Beiträgen als serialisierte RDF-Objekte und dem verwendeten Serialisierungsformat aufgerufen. Die folgenden Schritte werden dann für jeden \texttt{sioc:Post} in den serialisierten Daten durchgeführt:

Es beginnt damit, dass zuerst nach einem Benutzerkonto des Beitragautors für die Plattform des aktuellen Connectors gesucht wird. Dieser sollte im Idealfall im Triplestore des Connectors nach dem im Abschnitt \ref{sub:benutzerdaten} beschrieben Schema vorliegen. Mit diesem Benutzerkonto, in Form der Klasse \texttt{sioc:UserAccount} aus SIOC, kann dann vom ClientManager ein Client für die verwendete API geholt werden. Sollte die Suche negativ verlaufen, steht noch der Defaultclient zur Verfügung. Bevor der Beitrag aber geschrieben werden kann, muss nachgeschaut werden, ob eine Erlaubnis für das Schreiben mit diesem Client vorliegt. Ist dies der Fall kann der Beitrag in das von der API verwendete Format konvertiert und an die richtige Stellen der Plattform geschrieben werden.

\begin{figure}[ht]
    \centering
    \includegraphics[
        width=0.80\textwidth,
        keepaspectratio=true,
        clip=true,
        trim= 94 170 200 75]
    {assets/images/postwriter_sequencediagram}
    \caption{UML-Sequenzdiagramm eines PostWriters}
    \label{fig:postwriter_sequenzdiagramm}
\end{figure}

% subsubsection postwriter (end)

% subsection connector_aufbau (end)

% section social_online_community_connectors (end)

\section{SOCC-Camel} % (fold)
\label{sec:socc_camel}
%% korrigiert am 2013-09-26 22:04

\emph{SOCC-Camel} ist eine Modul von SOCC für die Integration von Connectoren in Camel. Durch dieses ist auf flexible Weise möglich die gelesenen Beiträge von einer Plattform über die Connectoren in eine andere zu schreiben. Die Abbildung \ref{fig:uebersicht_socc_camel} zeigt SOCC-Camel als EIP-Diagramm. 

Hauptklasse dieses Moduls ist \texttt{SoccComponent}. Sie ist für die Verwaltung von Connectoren und Erstellen der Endpunkte für Camel zuständig. Von dieser Klasse muss zuerst ein Objekt erzeugt und ein SoccContext mit dem Tripelstore und alle Informationen für die Connectoren wie für deren Konfiguration, Benutzerkonten oder Servicebeschreibungen übergeben werden. Also alle Daten die in Anschnitt \ref{sec:konfiguration} beschrieben wurden. Das SoccComponent-Objekt wird dann unter einen frei wählbaren Namen in Camel registriert. Als Namen ist \enquote{socc} aber vorzuziehen.  Nun kann wie in Abschnitt \ref{ssub:apache_camel} mit dieser Komponente Routen zusammengesetzt werden.

Die URIs für die Konfiguration der Endpunkte mit SOCC-Camel habe dazu den folgenden Aufbau: \enquote{\texttt{socc://{connectorId}?uri={targetUri}[\&{parameter}...]}}. Der Anfang der URI mit \enquote{\texttt{socc://}} sagt Camel, dass es für diesen Endpunkt die Komponente benutzten soll, die vorher unter dem Namen \enquote{socc} registriert wurde - also SoccComponent. Für den Platzhalter \enquote{\{connectorId\}} muss eine gültige ID eines Connectors sein, dessen Konfigurationsdaten im TripleStore hinterlegt wurden. Über den Parameter \enquote{uri} wird dann die Quell- beziehungsweise Ziel-URI für den Connector angegeben, von der Beiträge gelesen beziehungsweise in die Beiträge geschrieben werden sollen. Je nach Endpunkt können dann noch weitere Parameter angegeben werden. Ein Endpunkt wird in SOCC-Camel durch die Klasse \texttt{SoccEndpoint} modelliert (nicht explizit in der Abbildung angegeben) und leitet sich von der Camel-Klasse \texttt{ScheduledPollEndpoint} ab, die das Verwenden der folgenden \texttt{SoccPostPollConsumer} Klasse vereinfacht.

\begin{minipage}{\textwidth}
    \centering
     \includegraphics[
        width=\textwidth,
        keepaspectratio=true]
        {assets/images/socc_camel_overview}
    \captionof{figure}{Übersicht des SOCC-Camel Moduls als EIP-Diagramm.}
    \label{fig:uebersicht_socc_camel}
\end{minipage}

\subsection{SoccPostPollConsumer} % (fold)
\label{sub:soccpostpollingconsumer}

Wird ein Endpunkt mit der Absicht zum Lesen von Beiträgen erstellt, erzeugt die Klasse SoccEndpoint ein Objekt der Klasse SoccPostPollConsumer und übergibt im die Parameter aus der Konfigurations-URI. Da SoccPostPollingConsumer sich von der Camel-Klasse \texttt{ScheduledPollConsumer} ableitet, ist es über den Parameter \texttt{delay} möglich in periodischen Abständen das Lesen von Beiträgen auszuführen. Die Angabe erfolgt dabei in Millisekunden. Der Parameter \texttt{limit} entspricht dabei den gleichnamigen Argument der Methode \texttt{pollPosts(\dots)} des PostReaders aus Abschnitt \ref{sub:postreader}. Das dort noch fehlende Argument \texttt{since}, für das Datum, ab wann ein Beitrag als neu gilt, wird mit dem Zeitpunkt belegt, wann die Methode \texttt{pollPosts(\dots)} das letzte Mal aufgerufen wurde. Alle neuen, gelesenen Beiträge werden am Ende in das RDF/XML-Format serialisiert und als Nachricht an Camel übergeben. Damit andere Komponenten diese Nachricht wieder korrekt de-serialisieren können, muss der Nachricht noch ein Header mit dem Schlüssel \enquote{Content-Type} und dem MIME-Type\footnote{ Multipurpose Internet Mail Extension - Types: \url{http://tools.ietf.org/html/rfc2046}} vom RDF/XML \enquote{application/rdf+xml} als Wert mitgegeben werden.

% subsection soccpostpollconsumer (end)

\subsection{SoccPostProducer} % (fold)
\label{sub:soccpostproducer}

Der \texttt{SoccPostProducer} ist das Gegenstück zum SoccPostPollConsumer. Er ist der Endpunkt der zum Schreiben von Beiträgen in die Plattform des Connectors von der Klasse SoccEndpoint erzeugt wird. Intern verwendet er den PostWriter des betreffenden Connetors und leitet den Inhalt der Nachricht an diesen weiter. Außer der Angabe über die Ziel-URI erhält der SoccPostProducer keine weiteren Parameter über die Konfigurations-URI. Der SoccPostProducer überprüft auch ob ein gültiger MIME-Type angeben wurde. Akzeptiert wird auf jeden Fall \enquote{application/rdf+xml} für RDF/XML. Je nach verwendeten Adapter für RDF2Go können auch \enquote{application/x-turtle} für Turtle oder \enquote{application/rdf+json} für RDFJson\footnote{\url{https://dvcs.w3.org/hg/rdf/raw-file/default/rdf-json/index.html}} verwendet werden.

% subsection soccpostproducer (end)

% section socc_camel (end)

% chapter eigener_ansatz_social_online_community_connectors_socc_ (end)